// src/utils/workers.js
import { createCanvas } from "canvas";
import { readFile, writeFile, mkdir, appendFile } from "fs/promises";
import { existsSync, writeFileSync } from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));

// Environment-configurable directories
const ENV_CACHE_DIR = process.env.CACHE_DIR || "";
const ENV_LOGS_DIR = process.env.LOGS_DIR || "";

// By default use project-root ./cache and ./logs for local dev; allow override via env.
// If the chosen dir is not writable, fallback to /tmp.
const DEFAULT_CACHE_DIR = join(process.cwd(), "cache");
const DEFAULT_LOGS_DIR = join(process.cwd(), "logs");
const FALLBACK_TMP_DIR = "/tmp";

async function ensureWritableDir(dirCandidate, fallback = FALLBACK_TMP_DIR) {
  try {
    if (!dirCandidate) throw new Error("empty dirCandidate");
    // create dir recursively if missing
    await mkdir(dirCandidate, { recursive: true });
    // test write permission by writing and removing a tiny temp file
    const testFile = join(dirCandidate, `.writable_test_${Date.now()}`);
    await writeFile(testFile, "ok");
    // remove test file synchronously (small file)
    try { writeFileSync(testFile, ""); } catch (e) {}
    return dirCandidate;
  } catch (err) {
    // try fallback
    try {
      await mkdir(fallback, { recursive: true });
      const testFile2 = join(fallback, `.writable_test_${Date.now()}`);
      await writeFile(testFile2, "ok");
      try { writeFileSync(testFile2, ""); } catch (e) {}
      console.warn(
        `[workers] Directory "${dirCandidate}" not writable or missing; falling back to "${fallback}"`
      );
      return fallback;
    } catch (err2) {
      // Last resort: use current working directory (should rarely happen)
      const final = process.cwd();
      console.error(
        `[workers] Both "${dirCandidate}" and fallback "${fallback}" not writable. Using CWD: ${final}`
      );
      await mkdir(final, { recursive: true });
      return final;
    }
  }
}

let CACHE_DIR_PROMISE = null;
let LOGS_DIR_PROMISE = null;
async function getCacheDir() {
  if (!CACHE_DIR_PROMISE) {
    const candidate = ENV_CACHE_DIR || DEFAULT_CACHE_DIR;
    CACHE_DIR_PROMISE = ensureWritableDir(candidate, FALLBACK_TMP_DIR);
  }
  return CACHE_DIR_PROMISE;
}
async function getLogsDir() {
  if (!LOGS_DIR_PROMISE) {
    const candidate = ENV_LOGS_DIR || DEFAULT_LOGS_DIR;
    LOGS_DIR_PROMISE = ensureWritableDir(candidate, FALLBACK_TMP_DIR);
  }
  return LOGS_DIR_PROMISE;
}

// Utility: format last refresh time string (safe)
function formatIsoTimestampToReadable(isoString) {
  if (!isoString) return new Date().toISOString().replace("T", " ").split(".")[0];
  try {
    // e.g. 2025-10-30T08:00:00.000Z -> '2025-10-30 08:00:00'
    return isoString.replace("T", " ").split(".")[0];
  } catch (err) {
    return new Date().toISOString().replace("T", " ").split(".")[0];
  }
}

// Generate summary PNG into cache dir. Safe for containers and local dev.
export const generatePNG = async (
  total_countries,
  top_five_countries, // either string with newlines or an array of country names
  last_refresh_time // ISO string or null
) => {
  try {
    const cacheDir = await getCacheDir();

    // Normalize top_five into array
    let topArr = [];
    if (!top_five_countries) {
      topArr = [];
    } else if (Array.isArray(top_five_countries)) {
      topArr = top_five_countries;
    } else if (typeof top_five_countries === "string") {
      topArr = top_five_countries.split("\n").map((s) => s.trim()).filter(Boolean);
    } else {
      topArr = [String(top_five_countries)];
    }

    const width = 1200;
    const height = 600;
    const canvas = createCanvas(width, height);
    const ctx = canvas.getContext("2d");

    // Background
    ctx.fillStyle = "#1e293b";
    ctx.fillRect(0, 0, width, height);

    // Title
    ctx.fillStyle = "#ffffff";
    ctx.font = "bold 36px sans-serif";
    ctx.fillText("Countries Summary", 48, 48);

    // Total countries
    ctx.font = "28px sans-serif";
    ctx.fillText(`Total countries: ${total_countries}`, 48, 100);

    // Last refreshed
    ctx.font = "20px sans-serif";
    const formattedTime = formatIsoTimestampToReadable(last_refresh_time);
    ctx.fillText(`Last refreshed: ${formattedTime}`, 48, 140);

    // Top 5 block
    ctx.font = "26px sans-serif";
    ctx.fillText("Top 5 by estimated GDP:", 48, 190);
    ctx.font = "20px sans-serif";
    const startY = 230;
    topArr.slice(0, 5).forEach((c, i) => {
      const text = `${i + 1}. ${c}`;
      ctx.fillText(text, 72, startY + i * 36);
    });

    // Footer small note
    ctx.font = "14px sans-serif";
    ctx.fillText("Generated by countries service", 48, height - 48);

    const buffer = canvas.toBuffer("image/png");
    const filePath = join(cacheDir, "summary.png");
    await writeFile(filePath, buffer);

    // Also persist timestamp if provided
    if (last_refresh_time) {
      try {
        await writeFile(join(cacheDir, "timestamp.txt"), last_refresh_time, "utf-8");
      } catch (err) {
        console.warn(`[workers] Unable to write timestamp.txt to cacheDir: ${err.message}`);
      }
    }

    console.log(`[workers] PNG generated at ${filePath}`);
    return filePath;
  } catch (err) {
    console.error(`[workers] generatePNG error: ${err?.message || err}`);
    throw err;
  }
};

// Accepts array of country objects; returns newline-separated country names for top 5.
// If countries array empty or malformed returns empty string.
export const findTopFiveCountries = (countries) => {
  if (!Array.isArray(countries)) return "";
  const sortedArray = countries
    .slice()
    .filter((c) => c && typeof c.estimated_gdp === "number")
    .sort((a, b) => (b.estimated_gdp || 0) - (a.estimated_gdp || 0));
  const topFiveCountries = sortedArray.slice(0, 5).map((country) => country.name || "");
  return topFiveCountries.join("\n");
};

// Timestamp helpers
export const getLastRefreshTime = async () => {
  try {
    const cacheDir = await getCacheDir();
    const path = join(cacheDir, "timestamp.txt");
    try {
      const content = await readFile(path, "utf-8");
      return content;
    } catch (err) {
      // file doesn't exist or unreadable
      return null;
    }
  } catch (err) {
    console.error(`[workers] getLastRefreshTime error: ${err?.message || err}`);
    return null;
  }
};

export const setLastRefreshTime = async (lastRefreshTime) => {
  try {
    const cacheDir = await getCacheDir();
    await writeFile(join(cacheDir, "timestamp.txt"), lastRefreshTime, "utf-8");
    return true;
  } catch (err) {
    console.error(`[workers] setLastRefreshTime error: ${err?.message || err}`);
    return false;
  }
};

// Append logs to a file under logs dir
export const logEvents = async (logFileName, message) => {
  try {
    const logsDir = await getLogsDir();
    const filePath = join(logsDir, logFileName);
    const logItem = `Timestamp: ${new Date().toISOString()} | ${message}\n`;
    await appendFile(filePath, logItem, "utf-8");
    return true;
  } catch (err) {
    console.error(`[workers] logEvents error: ${err?.message || err}`);
    return false;
  }
};

// Return the summary image as a Buffer (or null)
export const getSummaryImage = async () => {
  try {
    const cacheDir = await getCacheDir();
    const filePath = join(cacheDir, "summary.png");
    try {
      const buf = await readFile(filePath);
      return buf;
    } catch (err) {
      console.warn(`[workers] getSummaryImage: no cached image found: ${err?.message || err}`);
      return null;
    }
  } catch (err) {
    console.error(`[workers] getSummaryImage error: ${err?.message || err}`);
    return null;
  }
};
